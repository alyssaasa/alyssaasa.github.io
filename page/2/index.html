<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#6c599f">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#6c599f">
  <meta name="google-site-verification" content="SJUudYL5q_atXSgew2qwy69FXOnSnNB2rAmwHmcBT9U">
  <meta name="baidu-site-verification" content="wvc37nzEad">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=EB+Garamond:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLong+Cang:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.dlzhang.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="二次元&#x2F;coser&#x2F;手办宅&#x2F;程序媛">
<meta property="og:type" content="website">
<meta property="og:title" content="醉里挑灯赏猫">
<meta property="og:url" content="https://blog.dlzhang.com/page/2/">
<meta property="og:site_name" content="醉里挑灯赏猫">
<meta property="og:description" content="二次元&#x2F;coser&#x2F;手办宅&#x2F;程序媛">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Alyssa">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.dlzhang.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>醉里挑灯赏猫</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-141207776-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-141207776-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>



<link rel="dns-prefetch" href="https://blog-waline-five.vercel.app/">


<link rel="preconnect" href="https://website-1256060851.file.myqcloud.com" crossorigin>
<link rel="preconnect" href="https://sdn.geekzu.org" crossorigin>





<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xiangsudian/CaoMei/style.min.css">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">醉里挑灯赏猫</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">努力努力再努力</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>博客首页</a></li>
        
            
  <li class="menu-item menu-item-overview"><a href="/overview/" rel="section"><i class="fas fa-archive fa-fw"></i>文章总览</a></li>


      
        <li class="menu-item menu-item-more"><a href="/more/" rel="section"><i class="fas fa-location-arrow fa-fw"></i>关于更多</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>全站搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Alyssa"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Alyssa</p>
  <div class="site-description" itemprop="description">二次元/coser/手办宅/程序媛</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/overview/timeline/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/overview/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/overview/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-09-08 21:30:11" itemprop="dateCreated datePublished" datetime="2019-09-08T21:30:11+08:00">2019-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/3/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/3/" data-xid="/posts/3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/3/" class="post-meta-item leancloud_visitors" data-flag-title="位运算" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="1-leetcode-136-Single-Number"><a href="#1-leetcode-136-Single-Number" class="headerlink" title="1. leetcode 136. Single Number"></a>1. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/">leetcode 136. Single Number</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty array of integers, every element appears twice except <span class="keyword">for</span> one. Find that single one.</span><br><span class="line">数组中只有一个数字出现了一次，其他数字都出现了<span class="number">2</span>次。找出这个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>异或。相同的两个数二进制异或为0.</li>
<li>所有的元素进行异或，最后的值即为出现一次的元素的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        res = res^nums[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-leetcode-137-Single-Number-II"><a href="#2-leetcode-137-Single-Number-II" class="headerlink" title="2. leetcode 137. Single Number II"></a>2. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number-ii/">leetcode 137. Single Number II</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty array of integers, every element appears three times except <span class="keyword">for</span> one, which appears exactly once. Find that single one.</span><br><span class="line">数组中只有一个数字出现了一次，其他数字都出现了<span class="number">3</span>次。找出这个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>我们把数组中的每个数字都转为二进制。</li>
<li>如果一个数字出现三次，那么二进制的每一位也都出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别累加起来，那么每一位的和都能被3整除。</li>
<li>那么我们就把所有数字的对应位都累加起来，如果能被3整除，那么出现一次的数字该位为0，否则该位为1，这样运算下来，我们就能知道只出现一次的这个数字的二进制表示，那么我们就可以得到这个数字的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3-leetcode-260-Single-Number-III"><a href="#3-leetcode-260-Single-Number-III" class="headerlink" title="3. leetcode 260. Single Number III"></a>3. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number-iii/">leetcode 260. Single Number III</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</span><br><span class="line">数组中有两个数字仅出现一次，其余数字都出现两次。找出仅出现一次的这两个数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>只有一个数字可以直接异或，因为其他部分异或都为0。而两个数字，就不能直接整个数组异或了，因为这两个只出现一次的数字也会求异或，所以得不到两个数字的值。如果能把这两个数字分开，分到两个不同的子数组里就好了。</li>
<li>如何划分到两个不同的子数组中呢？</li>
</ul>
<ol>
<li>假设不同的数字为a和b，</li>
<li>先将整个数组求异或，那么得到的就是a和b异或的值c</li>
<li>我们得到c的二进制值，找到第一个为1的位置。该位之所以为1，是因为a和b中只有一个该位置为1，那么我们就能够把a和b区分开了。</li>
<li>所以，我们假设c的第n位为1，那么我们将整个数组按照第n位是不是为1分成两个数组。那么a和b肯定在不同的数组中</li>
<li>同时，其他出现两次的每个数字，每个相同的两个数必出现在同一个子数组中，因为他们俩完全相等，第n位是不是1当然也是同样的结果。</li>
<li>也就是说，两个子数组中，除了a和b分别在自己的子数组中出现一次，其他数字都出现两次，那么我们将两个子数组分别求异或，就能得到a和b的值了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/11/" class="post-title-link" itemprop="url">时间复杂度问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-09-02 23:29:35" itemprop="dateCreated datePublished" datetime="2019-09-02T23:29:35+08:00">2019-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/11/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/11/" data-xid="/posts/11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/11/" class="post-meta-item leancloud_visitors" data-flag-title="时间复杂度问题" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><span>时间复杂度</span></h2><h3 id="一遍循环：O-n"><a href="#一遍循环：O-n" class="headerlink" title="一遍循环：O(n)"></a>一遍循环：O(n)</h3><h3 id="嵌套两遍循环：O-n-n"><a href="#嵌套两遍循环：O-n-n" class="headerlink" title="嵌套两遍循环：O(n*n)"></a>嵌套两遍循环：O(n*n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        .....</span><br></pre></td></tr></table></figure>

<h3 id="O-log-n-与-O-n-log-n-分析方法："><a href="#O-log-n-与-O-n-log-n-分析方法：" class="headerlink" title="O(log n) 与 O(n log n) 分析方法："></a>O(log n) 与 O(n log n) 分析方法：</h3><p>📍 自理解：一般这种带有 <code>logn</code> 都是有递归操作的。例如二分查找，就是每次我找到中间位置，然后如果查找的值大于当前值，那么我只需在后一半中继续查找，如果查找的值小于当前值，就在前一半中继续查找，每次我都可以减少一半数量的元素。其时间复杂度为 <code>O(logn)</code> 。像归并排序, 虽然我每次把整个array分成了两个部分，但是两个部分都需要去进行递归处理，那么时间复杂度就是 <code>O(nlogn)</code> 。</p>
<p>📍 通过递归深度来计算时间复杂度：</p>
<p><img data-src="/images/others/tree.png"></p>
<p><strong>快速排序的时间复杂度：</strong>快速排序是通过交换，找到中间位置的元素，然后左右两部分分别去递归进行排序。</p>
<p>如上图所示，如果快排每次选的节点恰好为中间节点，也就是二叉树是平衡的，那么二叉树的深度为 <code>log(n+1)</code> ，而在遍历每一层的时候，n个节点都会访问到。如上图 <code>B</code> 和 <code>C</code> 节点，虽然递归后不是一次访问n个节点，<code>B</code> 和 <code>C</code> 两次递归加起来就是总的节点个数n，一共有 <code>log(n+1)</code> 层，所以其时间复杂度为 <code>O(n*log(n+1)) = O(nlogn)</code></p>
<p><strong>二分查找的时间复杂度：</strong> 二分查找是每次访问中间节点，判断中间节点和我们要找的节点之间的大小，如果中间节点大于目标节点，那么只访问左半部分，否则只访问右半部分。</p>
<p>如上图所示，二叉树的深度为 <code>log(n+1)</code> ，先访问递归 <code>A</code>, 如果目标节点大于当前值 ，那么访问递归 <code>C</code>， 如果目标节点小于当前值，那么访问递归 <code>F</code>， 如果目标节点小于当前值，那么访问递归 <code>L</code>。从这个路径来看，在每一层的递归时，只需要访问一个节点，其时间复杂度为 <code>O(1)</code> 。二叉树的深度为 <code>log(n+1)</code> ， 所以二分查找的时间复杂度为 <code>O(1*log(n+1)) = O(logn)</code></p>
<p><strong>在未排序数组中寻找第k大的数的时间复杂度</strong>：寻找第k大的数，利用的是快速排序的思想，经过一轮排序，我们会找到一个元素的最终位置index，如果k大于index，那么我只要在后面继续快排，如果k小于index，那么就在前面快排。它和快排的区别在于我只要在一半的部分进行快排即可，而不需要两侧都进行快排。</p>
<p>如上图所示，二叉树的深度为 <code>log(n+1)</code> ，</p>
<ul>
<li>在第一层时，<code>n</code> 个节点都需要被访问到。</li>
<li>如果 k 大于 index，那么执行 <code>C</code> 侧的递归即可，这时需要访问的节点数为 <code>n/2</code>。 </li>
<li>如果 k 大于 index，那么执行 <code>G</code> 侧的递归即可，这时需要访问的节点数为 <code>n/4</code>。 </li>
<li>二叉树的深度为 <code>log(n+1)</code> ， 那么一共需要：$$n + \frac{n}{2} + \frac{n}{4} +…+ \frac{n}{2^{log(n+1)-1}} = \frac{2n^2}{n+1} = O(n)$$</li>
</ul>
<h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a><span>相关例题</span></h2><h3 id="leetcode-169-找出数组中出现次数大于一半的元素"><a href="#leetcode-169-找出数组中出现次数大于一半的元素" class="headerlink" title="leetcode 169. 找出数组中出现次数大于一半的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">leetcode 169. 找出数组中出现次数大于一半的元素</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/<span class="number">2</span> ⌋ 的元素。</span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在众数。</span><br></pre></td></tr></table></figure>

<ul>
<li>统计一遍。O(n)， 但需要额外的空间保存每个数字出现的次数。</li>
<li>排序。因为该元素出现次数大于一半，也就是说，排序后中间位置的数字一定是出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。而排序的时间复杂度最少也为O(nlogn).</li>
<li>排序后，中间的数字一定是出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素，也就是说我们只要找到排序后的中间元素就好了。这道题就可以转换为：找出第n/2大的数。</li>
<li>哈哈，这样就可以利用快排的特点了，那么就可以把时间复杂度缩小到O(n)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp_value = nums[begin];</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end) &#123;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;end &amp;&amp; nums[end]&gt;=tmp_value) end -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin &lt; end) nums[begin] = nums[end];</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;end &amp;&amp; nums[begin]&lt;=tmp_value) begin += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin &lt; end) nums[end] = nums[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[begin] = tmp_value;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, begin = <span class="number">0</span>, end = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index!=nums.length/<span class="number">2</span>) &#123;</span><br><span class="line">        index = partition(nums, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(index&gt;nums.length/<span class="number">2</span>) end = index-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index&lt;nums.length/<span class="number">2</span>) begin = index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指offer-找出数组中最小的k个数"><a href="#剑指offer-找出数组中最小的k个数" class="headerlink" title="剑指offer. 找出数组中最小的k个数"></a>剑指offer. 找出数组中最小的k个数</h3><ul>
<li>方法一：和上面一样，利用二分查找，找到最小的k个数，那么只要找到第k+1大的数，那么他之前的就是最小的k个数。这种方式会改变数组内的值</li>
<li>方法二：不改变数组的值。设置一个容器，存储空间为k，遍历数组，每遍历到一个数，判断容器里的最大值和当前值大小，如果当前值小于容器中的最大值，删除容器中的最大值，用当前值替换。</li>
<li>而在容器中找到最大值插入删除的操作，最省时的是构建最大堆。时间复杂度为O(log k)。那么总的时间复杂度就是O(n log k)</li>
<li>第二种方法对<strong>海量数据</strong>很有用，因为第一种方法需要一次把所有的数据都读进来，而第二种方法可以一个一个读入，辅助空间为k即可。n很大k很小时，这种方法很好。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="剑指offer-在排序数组中查找某数字出现的次数"><a href="#剑指offer-在排序数组中查找某数字出现的次数" class="headerlink" title="剑指offer. 在排序数组中查找某数字出现的次数"></a>剑指offer. 在排序数组中查找某数字出现的次数</h3><ul>
<li>利用二分查找，找到重复数字的左右端点。</li>
<li>查找左端点的时候，利用二分查找，如果当前节点为重复数字，看它和左边的节点是否相等，如果不相等，那么该节点为左端点。 右端点也是一样的。</li>
<li>找到左右端点的位置，就可以知道其出现次数了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="剑指offer-0到n-1中缺失的数字"><a href="#剑指offer-0到n-1中缺失的数字" class="headerlink" title="剑指offer. 0到n-1中缺失的数字"></a>剑指offer. 0到n-1中缺失的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长度为n-<span class="number">1</span>的递增序列，其中只有一个数字不存在。找到这个不存在的数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>就是找到第一个index与值不相等的元素。</li>
<li>二分查找 。如果当前值和index不等，并且前一个值和index相等，那么这个值就是我们想要的。</li>
</ul>
<h3 id="剑指offer-递增序列，找到值与index相等的任意一个元素。"><a href="#剑指offer-递增序列，找到值与index相等的任意一个元素。" class="headerlink" title="剑指offer.  递增序列，找到值与index相等的任意一个元素。"></a>剑指offer.  递增序列，找到值与index相等的任意一个元素。</h3><ul>
<li>如果当前值比index小，那么它前面不可能有了，只能向后找</li>
<li>如果当前值比index 大，那么它后面是不可能有了，只能向前找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="把数字翻译成字符串。"><a href="#把数字翻译成字符串。" class="headerlink" title="把数字翻译成字符串。"></a>把数字翻译成字符串。</h3><p>p 231.  46题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="leetcode-4-找到两个已排序数组的中位数"><a href="#leetcode-4-找到两个已排序数组的中位数" class="headerlink" title="leetcode 4. 找到两个已排序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/median-of-two-sorted-arrays/">leetcode 4. 找到两个已排序数组的中位数</a></h3><ul>
<li>最简单直接的方法，先将两个有序数组合并成一个有序数组，然后找到中位数。</li>
<li>合并时可以到 <code>(nums1.length + nums2.length)/2 + 1</code> 的时候就停止，因为我们的目的就是找中位数。</li>
<li>这种方法的时间复杂度是 <code>O(m+n)</code> 。 <code>m</code> 和 <code>n</code> 分别为两个数组的长度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums1.length + nums2.length;</span><br><span class="line">    <span class="keyword">int</span>[] res_arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">if</span>(nums1.length==<span class="number">0</span>) res_arr = Arrays.copyOf(nums2, nums2.length);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums2.length==<span class="number">0</span>) res_arr = Arrays.copyOf(nums1, nums1.length);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> begin_1 = <span class="number">0</span>, begin_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(begin_1&gt;=nums1.length) &#123;</span><br><span class="line">                res_arr[i] = nums2[begin_2];</span><br><span class="line">                begin_2 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(begin_2&gt;=nums2.length) &#123;</span><br><span class="line">                res_arr[i] = nums1[begin_1];</span><br><span class="line">                begin_1 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[begin_1]&lt;nums2[begin_2]) &#123;</span><br><span class="line">                    res_arr[i] = nums1[begin_1];</span><br><span class="line">                    begin_1 += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res_arr[i] = nums2[begin_2];</span><br><span class="line">                    begin_2 += <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==length/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums1.length + nums2.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = merge(nums1, nums2);</span><br><span class="line">    <span class="keyword">if</span>(length%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> (res[length/<span class="number">2</span>-<span class="number">1</span>] + res[length/<span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res[length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>涉及到有序数组，涉及到查找，就要想到<strong>二分查找</strong>！！</p>
</li>
<li><p>解释：<a target="_blank" rel="noopener" href="https://youtu.be/LPFhl65R7ww">https://youtu.be/LPFhl65R7ww</a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums2.length&lt;nums1.length) &#123; <span class="comment">//为了让nums1中存的是短的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> length = (nums1.length + nums2.length + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid1 = (begin + end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = length - mid1;</span><br><span class="line">        <span class="keyword">if</span>(mid1&lt;nums1.length &amp;&amp; nums2[mid2-<span class="number">1</span>]&gt;nums1[mid1]) &#123;</span><br><span class="line">            begin = mid1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid1&gt;<span class="number">0</span> &amp;&amp; nums1[mid1-<span class="number">1</span>]&gt;nums2[mid2])&#123;</span><br><span class="line">            end = mid1 - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> max_of_left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid1==<span class="number">0</span>) max_of_left = nums2[mid2-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid2==<span class="number">0</span>) max_of_left = nums1[mid1-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> max_of_left =  Math.max(nums1[mid1-<span class="number">1</span>], nums2[mid2-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((nums1.length + nums2.length)%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> max_of_left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> min_of_right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid1==nums1.length) min_of_right = nums2[mid2];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid2==nums2.length) min_of_right = nums1[mid1];</span><br><span class="line">            <span class="keyword">else</span> min_of_right =  Math.min(nums1[mid1], nums2[mid2]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-380-O-1-时间插入、删除、随即抽取"><a href="#leetcode-380-O-1-时间插入、删除、随即抽取" class="headerlink" title="leetcode 380. O(1)时间插入、删除、随即抽取"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1/">leetcode 380. O(1)时间插入、删除、随即抽取</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Design a data structure that supports all following operations in average <span class="title">O</span><span class="params">(<span class="number">1</span>)</span> time.</span></span><br><span class="line"><span class="function">1. <span class="title">insert</span><span class="params">(val)</span>: Inserts an item val to the set <span class="keyword">if</span> not already present.</span></span><br><span class="line"><span class="function">2. <span class="title">remove</span><span class="params">(val)</span>: Removes an item val from the set <span class="keyword">if</span> present.</span></span><br><span class="line"><span class="function">3. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>O(1)时间进行插入和删除操作，也就是不能遍历。</li>
<li>而且不能删除list中间的某一个元素，因为删除list中间的某一个元素的时间复杂度是O(n), 因为后面的元素需要全部向前面移动一位，也就是如果要使用list，那么只能删除最后一个元素。</li>
<li>可以使用hashmap，因为hashmap相当于链表，这道题又是set，也就是不存在重复元素。但是因为最后要随机抽取元素，只用map也不行，因为随机一个index之后，不能在map中去遍历，因为时间复杂度需要是O(1).</li>
<li>所以只能map和list一起用，map中存储元素值和其在list中的索引，每删除一个元素，那么我们需要把list中的最后一个元素和当前元素交换，然后删除最后一个元素。并且改变map中最后一个元素的value值，也就是在list中的索引值。这样随机取数的时候只要在list中get(index)即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// map里面存储值和该值在list种的索引</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize your data structure here. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Inserts a value to the set. </span></span><br><span class="line">    <span class="comment">// Returns true if the set did not already contain the specified element. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.putIfAbsent(val, list.size())==<span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Removes a value from the set. </span></span><br><span class="line">    <span class="comment">// Returns true if the set contained the specified element.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = map.getOrDefault(val, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">if</span>(index==Integer.MAX_VALUE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.remove(val);</span><br><span class="line">            <span class="keyword">if</span>(index&lt;list.size()-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 用list中的最后一个元素替换该位置的值</span></span><br><span class="line">                list.set(index, list.get(list.size()-<span class="number">1</span>)); </span><br><span class="line">                <span class="comment">// 改变map中该元素对应的value值，即其在list中的索引</span></span><br><span class="line">                map.put(list.get(list.size()-<span class="number">1</span>), index); </span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>); <span class="comment">// 删除list中的最后一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a random element from the set. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = (<span class="keyword">int</span>)(Math.random()*(list.size()));</span><br><span class="line">        <span class="keyword">return</span> list.get(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-381-O-1-时间插入、删除、随即抽取-允许重复"><a href="#leetcode-381-O-1-时间插入、删除、随即抽取-允许重复" class="headerlink" title="leetcode 381. O(1)时间插入、删除、随即抽取 (允许重复)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">leetcode 381. O(1)时间插入、删除、随即抽取 (允许重复)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Note: Duplicate elements are allowed.</span><br><span class="line"><span class="number">1.</span> insert(val): Inserts an item val to the collection.</span><br><span class="line"><span class="number">2.</span> remove(val): Removes an item val from the collection <span class="keyword">if</span> present.</span><br><span class="line"><span class="number">3.</span> getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/13/" class="post-title-link" itemprop="url">洗牌算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-09-01 20:00:12" itemprop="dateCreated datePublished" datetime="2019-09-01T20:00:12+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/13/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/13/" data-xid="/posts/13/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/13/" class="post-meta-item leancloud_visitors" data-flag-title="洗牌算法" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="洗牌算法定义"><a href="#洗牌算法定义" class="headerlink" title="洗牌算法定义"></a><span>洗牌算法定义</span></h2><p>之前两次面试都被问到洗牌算法，虽然不是直接问的，但都是基于洗牌算法的。结果第一次被问到之后没有重视，导致在一个地方栽了两次坑。。。😭</p>
<blockquote>
<p>洗牌算法，就是给你一个1到n的序列，让你随机打乱，保证每个数出现在任意一个位置的概率相同。换句话说，经过洗牌的数组的排列组合有n!种可能。</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a><span>解法</span></h2><h3 id="Fisher-Yates-Shuffle-算法-动态演示"><a href="#Fisher-Yates-Shuffle-算法-动态演示" class="headerlink" title="Fisher-Yates Shuffle 算法 动态演示"></a>Fisher-Yates Shuffle 算法 <a target="_blank" rel="noopener" href="https://bost.ocks.org/mike/shuffle/">动态演示</a></h3><ul>
<li><p>思想：从原始数组中随机取一个之前没有取过的数字到新的数组中。</p>
</li>
<li><p>步骤：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>. 初始化原始数组和新数组，原始数组长度为n（已知）；</span><br><span class="line"><span class="attribute">2</span>. 从还没处理的数组（假如还剩k个）中，随机产生一个[<span class="number">0</span>, k)之间的数字p（数组下标从<span class="number">0</span>开始）；</span><br><span class="line"><span class="attribute">3</span>. 从剩下的k个数中第p个数取出；</span><br><span class="line"><span class="attribute">4</span>. 重复步骤<span class="number">2</span>，<span class="number">3</span>直到数字全部取完；</span><br><span class="line"><span class="attribute">5</span>. 从步骤<span class="number">3</span>中去除的数字序列便是一个打乱的数列。</span><br></pre></td></tr></table></figure></li>
<li><p>证明：证明其随机性，即每个元素被放置在新数组中的第 <code>i</code> 个位置是 <code>1/n</code><br>一个元素m被放入第 <code>i</code> 个位置的概率 P = 前 <code>i-1</code> 个位置选择元素时没有选中m的概率 * 第 <code>i</code> 个位置选中m的概率，即:</p>
<p>$$P = \frac{n-1}{n} * \frac{n-2}{n-1} * … * \frac{n-i+1}{n-i+2} * \frac{1}{n-i+1} = \frac{1}{n}$$</p>
</li>
<li><p><strong>时间复杂度为O(n*n),空间复杂度为O(n).</strong></p>
</li>
<li><p>时间复杂度为O(n*n) 是因为我们要删除list中的元素，那么也就是要将后面的元素都向前移动一位，导致时间复杂度为O(n*n) .</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList <span class="title">Fisher_Yates_Shuffle</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; tar_arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="comment">// 生成0-n的随机数，包括0不包括n -- [0,n)</span></span><br><span class="line">        <span class="keyword">int</span> p =(<span class="keyword">int</span>)(Math.random()*(n-i));</span><br><span class="line">        tar_arr.add(arr.get(p));</span><br><span class="line">        arr.remove(p);  <span class="comment">// 删除index=p位置的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tar_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Knuth-Durstenfeld-Shuffle-算法"><a href="#Knuth-Durstenfeld-Shuffle-算法" class="headerlink" title="Knuth-Durstenfeld Shuffle 算法"></a>Knuth-Durstenfeld Shuffle 算法</h3><ul>
<li>对1的算法进行了改进，直接在原始数组上进行交换，而不必开辟额外的数组，节省空间。</li>
<li>思想：每次从未处理的数字中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</li>
<li>步骤：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</span><br><span class="line"><span class="bullet">2.</span> 生成一个从 0 到 n - 1 的随机数 x；</span><br><span class="line"><span class="bullet">3.</span> 输出 arr 下标为 x 的数值，即为第一个随机数；</span><br><span class="line"><span class="bullet">4.</span> 将 arr 的尾元素和下标为 x 的元素互换；</span><br><span class="line"><span class="bullet">5.</span> 同2，生成一个从 0 到 n - 2 的随机数 x；</span><br><span class="line"><span class="bullet">6.</span> 输出 arr 下标为 x 的数值，为第二个随机数；</span><br><span class="line"><span class="bullet">7.</span> 将 arr 的倒数第二个元素和下标为 x 的元素互换；</span><br></pre></td></tr></table></figure></li>
<li><strong>时间复杂度为O(n),空间复杂度为O(1)。缺点：必须知道数组长度n.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Knuth_Durstenfeld_Shuffle</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="comment">// 生成0-n的随机数，包括0不包括n -- [0,n)</span></span><br><span class="line">        <span class="keyword">int</span> p =(<span class="keyword">int</span>)(Math.random()*(n-i));</span><br><span class="line">        swap(arr, p, n-i-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inside-Out-Algorithm-算法"><a href="#Inside-Out-Algorithm-算法" class="headerlink" title="Inside-Out Algorithm 算法"></a>Inside-Out Algorithm 算法</h3><ul>
<li> Knuth-Durstenfeld Shuffle 是一个内部打乱的算法，算法完成后原始数据被直接打乱，尽管这个方法可以节省空间，但在有些应用中可能需要保留原始数据，所以需要另外开辟一个数组来存储生成的新序列。</li>
<li>Inside-Out Algorithm 算法是既可以开辟新的空间，而且不需要对原数组进行删除操作。</li>
<li>思想：设一游标i从前向后扫描原始数据的拷贝，在[0, i]之间随机一个下标p，然后用位置p的元素替换掉位置i的数字，再用原始数据位置i的元素替换掉拷贝数据位置p的元素。其作用相当于在拷贝数据中交换i与p位置处的值。</li>
<li><strong>时间复杂度为O(n),空间复杂度为O(n)</strong></li>
<li>这个算法的一个优点就是可以处理n未知的数组。</li>
<li>这个相当于：<code>1*2*3*4*5*6*7*...*n = n!</code> 种可能情况。</li>
<li>而前两种洗牌算法都相当于：<code>n*n-1*n-2*n-3*...*1 = n!</code> 种可能情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] Inside_Out_Shuffle(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] tar_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    tar_arr = arr.clone();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = (<span class="keyword">int</span>)(Math.random()*(i+<span class="number">1</span>));</span><br><span class="line">        tar_arr[i] = tar_arr[p];</span><br><span class="line">        tar_arr[p] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tar_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：之前Inside-Out Algorithm看了半天，没搞明白为什么需要那么麻烦两个数组替换来替换去的。。搞这么一波骚操作，但其实，Inside-Out Algorithm算法和Knuth-Durstenfeld Shuffle 算法的区别就在于一个原地打乱，一个在新数组上打乱。那么我们就可以先拷贝一份原数组，然后在新数组上按照Knuth-Durstenfeld Shuffle 算法的方法执行一遍就行了。两个数组替换实际上就是代替了原来的swap操作，不用额外开辟一个空间给暂存数据。而且Inside-Out Algorithm是从前向后处理的，可以处理n未知的数组。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><span>例题</span></h2><h3 id="leetcode-384-数组随即洗牌"><a href="#leetcode-384-数组随即洗牌" class="headerlink" title="leetcode 384. 数组随即洗牌"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shuffle-an-array/">leetcode 384. 数组随即洗牌</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12/" class="post-title-link" itemprop="url">查找算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-28 01:14:49" itemprop="dateCreated datePublished" datetime="2019-08-28T01:14:49+08:00">2019-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/12/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/12/" data-xid="/posts/12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/12/" class="post-meta-item leancloud_visitors" data-flag-title="查找算法" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-21 21:30:11" itemprop="dateCreated datePublished" datetime="2019-08-21T21:30:11+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/6/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/6/" data-xid="/posts/6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/6/" class="post-meta-item leancloud_visitors" data-flag-title="图" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>图，最多的遇到的面试题就是深度优先搜索和广度优先搜索，这也是最基础的。<br>图的一个最重要的点：<strong>设置一个 visit[] 数组，用来表示图中的每个节点是否已经被访问过</strong>。</p>
</blockquote>
<h2 id="图的深度优先搜索和广度优先搜索"><a href="#图的深度优先搜索和广度优先搜索" class="headerlink" title="图的深度优先搜索和广度优先搜索"></a><span>图的深度优先搜索和广度优先搜索</span></h2><ul>
<li><p>图分为邻接矩阵和邻接表。</p>
</li>
<li><p>邻接矩阵：<br><img data-src="/images/graph/2.png"></p>
</li>
<li><p>邻接表：<br><img data-src="/images/graph/3.png"></p>
</li>
<li><p>不管是 DFS 还是 BFS，都要设置一个 visit 变量，表示当前 node 是否已经被访问过，使用递归遍历所有的节点。</p>
</li>
</ul>
<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h3><ul>
<li>访问顶点v；</li>
<li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li>
<li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] visit, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    visit[node] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 访问node节点要执行的操作</span></span><br><span class="line">    System.out.println(node);</span><br><span class="line">    <span class="comment">//DFS遍历其他节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[node].length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(graph[node][i]==<span class="number">1</span> &amp;&amp; visit[i]==<span class="number">0</span>)</span><br><span class="line">            DFS(graph, visit, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h3><ul>
<li>首先将根节点放入队列中;</li>
<li>从队列中取出第一个节点, 将它所有尚未检验过的直接子节点加入队列中;</li>
<li>若队列为空，表示整张图都检查过了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] visit, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    visit[node] = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    que.add(node);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> new_node = que.poll();</span><br><span class="line">        <span class="comment">// 访问node节点要执行的操作</span></span><br><span class="line">        System.out.println(new_node);</span><br><span class="line">        <span class="comment">// 将new_node相连的节点放入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[new_node].length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[new_node][i]==<span class="number">1</span> &amp;&amp; visit[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                visit[i] = <span class="number">1</span>;</span><br><span class="line">                que.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a><span>经典题</span></h2><h3 id="leetcode-200-岛屿的数量"><a href="#leetcode-200-岛屿的数量" class="headerlink" title="leetcode 200. 岛屿的数量"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">leetcode 200. 岛屿的数量</a></h3><ul>
<li>1为陆地，0为水，垂直方向才能算作一个岛屿，斜着不能算作一个岛屿。</li>
<li>类似题目1：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-area-of-island/">leetcode 695. 岛屿的最大面积</a>，只需再增加一个计数功能即可。</li>
<li>类似题目2：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/flood-fill/">leetcode 733. Flood Fill</a>,  访问节点时再改变一下节点的值即可。</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">islandDFS</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span>[][] visit, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=grid.length || j&lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; visit[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">        visit[i][j] = <span class="number">1</span>;</span><br><span class="line">        islandDFS(grid, visit, i, j-<span class="number">1</span>);</span><br><span class="line">        islandDFS(grid, visit, i, j+<span class="number">1</span>);</span><br><span class="line">        islandDFS(grid, visit, i+<span class="number">1</span>, j);</span><br><span class="line">        islandDFS(grid, visit, i-<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] visit = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; visit[i][j]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 把和grid[i][j]相连接的位置都标记为1，记作一块岛屿</span></span><br><span class="line">                islandDFS(grid, visit, i, j);</span><br><span class="line">                number += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-463-确定岛屿的周长"><a href="#leetcode-463-确定岛屿的周长" class="headerlink" title="leetcode 463. 确定岛屿的周长"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/island-perimeter/">leetcode 463. 确定岛屿的周长</a></h3><ul>
<li>题目中只有一个岛屿，确定岛屿的周长</li>
<li>就是确定每个1周围有几个0，或者在边界位置。</li>
<li>这道题跟图没什么关系。遍历一遍就行了。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从头到尾遍历，查看每个1周围几个0，上下左右。</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || grid[i-<span class="number">1</span>][j]==<span class="number">0</span>) number += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span> || grid[i][j-<span class="number">1</span>]==<span class="number">0</span>) number += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==grid.length-<span class="number">1</span> || grid[i+<span class="number">1</span>][j]==<span class="number">0</span>) number += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==grid[<span class="number">0</span>].length-<span class="number">1</span> || grid[i][j+<span class="number">1</span>]==<span class="number">0</span>) number += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-787-从src飞到dst的最小花销"><a href="#leetcode-787-从src飞到dst的最小花销" class="headerlink" title="leetcode. 787 从src飞到dst的最小花销"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">leetcode. 787 从src飞到dst的最小花销</a></h3><ul>
<li>方法一：递归调用，但leetcode会超时。</li>
<li>优化：对于遍历到的结点，首先判断如果当前结点已经访问过了，直接跳过。或者是当前价格out加上到达这个结点需要的价格之和大于结果res的话，那么直接跳过。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> [][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K, <span class="keyword">int</span> v, <span class="keyword">int</span>[] visit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(src==dst &amp;&amp; v&lt;min) &#123;</span><br><span class="line">        min = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(K&lt;<span class="number">0</span>||v&gt;min) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flights.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[src]==<span class="number">0</span> &amp;&amp; flights[i][<span class="number">0</span>]==src) &#123;</span><br><span class="line">            visit[src] = <span class="number">1</span>;</span><br><span class="line">            DFS(flights, flights[i][<span class="number">1</span>], dst, K-<span class="number">1</span>, v+flights[i][<span class="number">2</span>], visit);    </span><br><span class="line">            visit[src] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] f, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] visit = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    DFS(f, src, dst, K, <span class="number">0</span>, visit);</span><br><span class="line">    <span class="keyword">if</span>(min == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-529-扫雷游戏"><a href="#leetcode-529-扫雷游戏" class="headerlink" title="leetcode 529. 扫雷游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minesweeper/">leetcode 529. 扫雷游戏</a></h3><ul>
<li>题太复杂了。。之后再做。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><span>拓扑排序</span></h2><hr>
<p>图片来源： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/XMU-hcq/p/6065057.html">https://www.cnblogs.com/XMU-hcq/p/6065057.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-21 21:30:11" itemprop="dateCreated datePublished" datetime="2019-08-21T21:30:11+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/7/" data-xid="/posts/7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/7/" class="post-meta-item leancloud_visitors" data-flag-title="字符串" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><span>例题</span></h2><h3 id="leetcode-316-删除字符串中的重复字符"><a href="#leetcode-316-删除字符串中的重复字符" class="headerlink" title="leetcode 316. 删除字符串中的重复字符"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicate-letters/">leetcode 316. 删除字符串中的重复字符</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</span><br><span class="line">Example <span class="number">1</span>:  Input: <span class="string">&quot;bcabc&quot;</span>      Output: <span class="string">&quot;abc&quot;</span></span><br><span class="line">Example <span class="number">2</span>:  Input: <span class="string">&quot;cbacdcbc&quot;</span>   Output: <span class="string">&quot;acdb&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为只有26个小写字母，所以可以用数组模拟 hashmap 先统计每个字符出现的次数。</li>
<li>然后要用辅助栈。其实发现很多问题都是数组和栈辅助进行操作，来对比当前元素和栈顶元素的大小，从而进行相应的操作。删除栈顶元素还是向栈中添加元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];  <span class="comment">// 统计每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];  <span class="comment">// 表示某个字符是否已经出现在栈中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch : s.toCharArray())  </span><br><span class="line">        count[ch-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">    Stack&lt;Character&gt; sta = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">        count[ch-<span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit[ch-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果当前元素比栈顶元素小，并且栈顶元素次数不等0</span></span><br><span class="line">        <span class="comment">// 那么就把栈顶元素弹出来，把当前元素入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.isEmpty() &amp;&amp; ch&lt;sta.peek() &amp;&amp; count[sta.peek()-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>) </span><br><span class="line">            visit[sta.pop()-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">false</span>;</span><br><span class="line">        sta.push(ch);</span><br><span class="line">        visit[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!sta.isEmpty())</span><br><span class="line">        res = sta.pop()+res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-567-字符串中的全排列"><a href="#leetcode-567-字符串中的全排列" class="headerlink" title="leetcode 567. 字符串中的全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-in-string/">leetcode 567. 字符串中的全排列</a></h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given two strings s1 <span class="keyword">and</span> s2, <span class="built_in">write</span> a function <span class="keyword">to</span> <span class="literal">return</span> <span class="literal">true</span> <span class="keyword">if</span> s2 <span class="keyword">contains</span> <span class="keyword">the</span> permutation <span class="keyword">of</span> s1. In other <span class="built_in">words</span>, one <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">first</span> <span class="built_in">string</span>&#x27;s permutations <span class="keyword">is</span> <span class="keyword">the</span> substring <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="built_in">string</span>.</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: s<span class="number">1</span> = <span class="string">&quot;ab&quot;</span> s<span class="number">2</span> = <span class="string">&quot;eidbaooo&quot;</span></span><br><span class="line"><span class="attribute">Output</span>: True</span><br><span class="line"><span class="attribute">Explanation</span>: s<span class="number">2</span> contains one permutation of s<span class="number">1</span> (<span class="string">&quot;ba&quot;</span>).</span><br></pre></td></tr></table></figure>

<ul>
<li>最直观的做法就是把s1的全排列都列出来，然后看每个全排列是不是s2的子串，但是当字符串的长度过长时，会超时。</li>
<li><strong>如何判断字符串m是不是字符串n的全排列，我们只要把字符串m和字符串n中的每个字符出现的次数做统计，如果两者每个字符出现的次数都相等，那么就证明字符串m是字符串n的一个全排列。</strong></li>
<li>如何判断字符串n是不是包含字符串m的全排列，也就是字符串m的全排列是不是字符串n的一个子串，那么我们就需要<strong>建立一个长度为m.length的滑动窗口</strong>，判断n的这个滑动窗口中n子串和m字符串每个字符出现的次数是不是相等。</li>
<li>但每到一个滑动窗口都重新统计一次次数很麻烦，每次移动滑动窗口的时候，只有左侧被移出去的字符和右侧被移进来的字符的次数有变化，那么我们把左侧移出去的字符数-1，右侧移进来的字符数+1，即为当前窗口n的每个字符出现的次数。</li>
<li>该题的类似题目：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">leetcode 438. 找到s1的全排列在s2中的位置</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.length()&gt;s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//统计s1中每个字符出现的次数，s2中每个长度为s1.length的窗口中字符出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] hash1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] hash2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++) &#123;</span><br><span class="line">        hash1[s1.charAt(i)-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        hash2[s2.charAt(i)-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Arrays.equals(hash1, hash2))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s1.length();i&lt;s2.length();i++) &#123;</span><br><span class="line">        hash2[s2.charAt(i)-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        hash2[s2.charAt(i-s1.length())-<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(hash1, hash2))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-179-将数组进行排序，使之组成的数最大-实则为对字符串排序"><a href="#leetcode-179-将数组进行排序，使之组成的数最大-实则为对字符串排序" class="headerlink" title="leetcode 179. 将数组进行排序，使之组成的数最大 (实则为对字符串排序)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-number/">leetcode 179. 将数组进行排序，使之组成的数最大 (实则为对字符串排序)</a></h3><ul>
<li>输入：<code>[3,30,34,5,9]</code> </li>
<li>输出：<code>9534330</code></li>
<li>特殊问题：<code>[2, 2281]</code>   <code>[12, 121]</code>   <code>[23, 234]</code></li>
<li>碰到长度不等时，会有些问题，比如第一个要交换。第二个不要交换；第三个要交换</li>
<li>最好的办法就是直接把两个字符串m和n拼接起来，然后比较mn和nm的大小即可，不存在长度不等的情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"> String tmp = str[i];</span><br><span class="line"> str[i] = str[j];</span><br><span class="line"> str[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为这道题涉及到了长度不同，谁放在前面的问题，不能简单地直接逐个字符比较</span></span><br><span class="line"><span class="comment">//那么，把m和n拼接成的mn和nm按照字符串大小的比较规则来处理即可。</span></span><br><span class="line"><span class="comment">//如果mn &lt; nm,应该打印出nm,即n应该排在m前面，要交换顺序，反之，m应该排在n前面。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    String new_1 = a+b;</span><br><span class="line">    String new_2 = b+a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;new_1.length();i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(new_1.charAt(i)==new_2.charAt(i)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> new_1.charAt(i)&lt;new_2.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;  <span class="comment">// 先将数组中的数字转为字符串，再去比较。</span></span><br><span class="line">        str[i] = nums[i]+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写个冒泡排序，任何一种排序算法都可以，只要把交换的条件变为我们的cmp条件即可。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cmp(str[j], str[j+<span class="number">1</span>])) &#123;</span><br><span class="line">                swap(str, j, j+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++) &#123;</span><br><span class="line">        result += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>; <span class="comment">//防止出现&quot;00&quot;的情况。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/10/" class="post-title-link" itemprop="url">数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-21 21:30:11" itemprop="dateCreated datePublished" datetime="2019-08-21T21:30:11+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/10/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/10/" data-xid="/posts/10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/10/" class="post-meta-item leancloud_visitors" data-flag-title="数组" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数组的全排列"><a href="#数组的全排列" class="headerlink" title="数组的全排列"></a><span>数组的全排列</span></h2><h3 id="leetcode-31-给出全排列的下一个排列"><a href="#leetcode-31-给出全排列的下一个排列" class="headerlink" title="leetcode 31. 给出全排列的下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/">leetcode 31. 给出全排列的下一个排列</a></h3><ul>
<li>输入1: <code>1,2,3,4,3,8,7,6,5</code> → <code>1,2,3,4,5,3,6,7,8</code></li>
<li>输入2: <code>3,2,1</code> → <code>1,2,3</code></li>
<li>条件：在nums数组上就地转换，并且要使用常数级辅助空间</li>
<li><strong>从后向前，找到递减的位置，然后从后面找到比他大的第一个元素，交换，然后对后面从小到大排序即可</strong></li>
<li>如果当前已经是最大，那么就输出他的最小值  从小到大排序即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(end-begin+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">        swap(nums, begin+i, end-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=nums[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//nums[i-1]是递减的那个值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=nums.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对后面逆序</span></span><br><span class="line">            reverse(nums, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-46-无重复数字数组的全排列"><a href="#leetcode-46-无重复数字数组的全排列" class="headerlink" title="leetcode 46. 无重复数字数组的全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">leetcode 46. 无重复数字数组的全排列</a></h3><ul>
<li>输入：[1,2,3]</li>
<li>输出：[1,2,3]   [1,3,2]  [2,1,3]  [2,3,1]  [3,1,2]  [3,2,1]</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] visit, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp_res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp_res.size()==nums.length) &#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        tmp.addAll(tmp_res);</span><br><span class="line">        result.add(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">0</span>) &#123;</span><br><span class="line">            tmp_res.add(nums[i]);</span><br><span class="line">            visit[i] = <span class="number">1</span>;</span><br><span class="line">            get_permute(nums, visit, result, tmp_res);</span><br><span class="line">            tmp_res.remove(tmp_res.size()-<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] visit = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List&lt;Integer&gt; tmp_res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    get_permute(nums, visit, result, tmp_res);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-47-有重复数字的全排列"><a href="#leetcode-47-有重复数字的全排列" class="headerlink" title="leetcode 47. 有重复数字的全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">leetcode 47. 有重复数字的全排列</a></h3><ul>
<li>输入：[1,2,1]</li>
<li>输出：[1,1,2]  [1,2,1]  [2,1,1]</li>
<li>有重复数字时，可以使用set代替之前的list,因为set本身就有过滤重复的用途。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] visit, Set&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tmp_res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp_res.size()==nums.length) &#123;</span><br><span class="line">     List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        tmp.addAll(tmp_res);</span><br><span class="line">        result.add(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">0</span>) &#123;</span><br><span class="line">            tmp_res.add(nums[i]);</span><br><span class="line">            visit[i] = <span class="number">1</span>;</span><br><span class="line">            get_permute(nums, visit, result, tmp_res);</span><br><span class="line">            tmp_res.remove(tmp_res.size()-<span class="number">1</span>);</span><br><span class="line">            visit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> HashSet();</span><br><span class="line">true<span class="keyword">int</span>[] visit = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    get_permute(nums, visit, res, list);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(List&lt;Integer&gt; list1:res)</span><br><span class="line">        result.add(list1);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是这种做法会比较复杂，不管相同不相同的数字，都会进行一次全排列，会比较耗时，所以可以先将数组排序，将相同的放在一起，如果取出下一个元素和上一个相同，那么这一轮就可以不再进行全排列了。</li>
</ul>
<h3 id="leetcode-60-取特定位置的全排列字符串"><a href="#leetcode-60-取特定位置的全排列字符串" class="headerlink" title="leetcode 60. 取特定位置的全排列字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-sequence/">leetcode 60. 取特定位置的全排列字符串</a></h3><ul>
<li>n=3, 则全排列为：<code>&quot;123&quot;</code> <code>&quot;132&quot;</code> <code>&quot;213&quot;</code> <code>&quot;231&quot;</code> <code>&quot;312&quot;</code> <code>&quot;321&quot;</code>，若k=3, 则输出为：<code>&quot;213&quot;</code></li>
<li>n=4, k=9, 则输出为：<code>&quot;2314&quot;</code></li>
<li>第一个位置有n中情况，第二个位置n-1中情况，…对于给定的n，其全排列中n!中情况。</li>
<li>求第一个位置的值时：k/(n-1)!  = shang…yu, 若yu&gt;0, 则拿到shang位置的值。其他同理</li>
<li>4 13     13/6 = 2…1    3</li>
<li>7/2! = 7/2 = 3…1   </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="给定第k个全排列，求倒数第k个全排列"><a href="#给定第k个全排列，求倒数第k个全排列" class="headerlink" title="给定第k个全排列，求倒数第k个全排列"></a>给定第k个全排列，求倒数第k个全排列</h3><ul>
<li>n=3, 则全排列为：<code>&quot;123&quot;</code> <code>&quot;132&quot;</code> <code>&quot;213&quot;</code> <code>&quot;231&quot;</code> <code>&quot;312&quot;</code> <code>&quot;321&quot;</code></li>
<li>给定k=3, 第3个全排列为 <code>&quot;213&quot;</code> ，则输出为：<code>&quot;231&quot;</code></li>
<li>这道题比较有规律，倒数第k个全排列，就是n+1减去正数第k个全排列每个位置上面的值。</li>
<li>例：k=2, n=3：正数：<code>&quot;132&quot;</code>；倒数：(n+1-1)(n+1-3)(n+1-2)=<code>&quot;312&quot;</code> </li>
</ul>
<h2 id="输出所有和为target的数组"><a href="#输出所有和为target的数组" class="headerlink" title="输出所有和为target的数组"></a><span>输出所有和为target的数组</span></h2><h3 id="先来一个类似的简单题：leetcode-633-判断一个值可否由两个数的平方和组成"><a href="#先来一个类似的简单题：leetcode-633-判断一个值可否由两个数的平方和组成" class="headerlink" title="先来一个类似的简单题：leetcode 633. 判断一个值可否由两个数的平方和组成"></a>先来一个类似的简单题：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-square-numbers/">leetcode 633. 判断一个值可否由两个数的平方和组成</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whether there<span class="string">&#x27;re two integers a and b such that a^2 + b^2 = c.</span></span><br><span class="line"><span class="string">例如：输入5，返回true， 因为 1 * 1 + 2 * 2 = 5。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解法：设置两个变量，i=0, j= $\sqrt5$ 的向下取整， 若$i<em>i+j</em>j&lt;c$, 则增大i，否则减小j，直到i&gt;j或找到满足条件的值为止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = i*i+j*j;</span><br><span class="line">        <span class="keyword">if</span>(value==c) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;c) j -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;c) i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-15-threesum-输出所有和为0的数组"><a href="#leetcode-15-threesum-输出所有和为0的数组" class="headerlink" title="leetcode 15. threesum, 输出所有和为0的数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/">leetcode 15. threesum, 输出所有和为0的数组</a></h3><ul>
<li><p>先将数组进行排序。</p>
</li>
<li><p>设置两个指针，一个指向数组头，一个指向数组尾，向中间移动。</p>
</li>
<li><p>如果指针指向的两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。</p>
</li>
<li><p>同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些。</p>
</li>
<li><p>直到找到满足条件的两个值。</p>
</li>
<li><p>因为该道题是三个数的和为target，所以需要先确定一个数，然后让new_target = target-当前值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>-nums[i];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; left!=i &amp;&amp; right!=i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]+nums[right]&gt;target)</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]&lt;target)</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Integer&gt; tmp_res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                tmp_res.add(nums[left]);</span><br><span class="line">                tmp_res.add(nums[i]);</span><br><span class="line">                tmp_res.add(nums[right]);</span><br><span class="line">                res.add(tmp_res);</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Iterator&lt;List&lt;Integer&gt;&gt; iterator = res.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        result.add(iterator.next());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-16-三个数的和最接近target"><a href="#leetcode-16-三个数的和最接近target" class="headerlink" title="leetcode 16. 三个数的和最接近target"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">leetcode 16. 三个数的和最接近target</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> new_tar = target - nums[i];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; left!=i &amp;&amp; right!=i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]+nums[right]&gt;new_tar)</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]&lt;new_tar)</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = left==i? left-<span class="number">1</span>: left;</span><br><span class="line">        right = right==i ? right+<span class="number">1</span>:right;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i] + nums[left] + nums[right];</span><br><span class="line">        res = Math.abs(target-tmp)&lt;Math.abs(target-res)?tmp:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a><span>其他题目</span></h2><h3 id="leetcode-56-Merge-Intervals"><a href="#leetcode-56-Merge-Intervals" class="headerlink" title="leetcode 56. Merge Intervals"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/">leetcode 56. Merge Intervals</a></h3><ul>
<li>将数组有重叠的部分进行合并。</li>
<li>先将数组按照第一个元素的位置排序，然后比较前一个的第二个值与后一个的第一个值</li>
<li>如果前一个的第二个值大于后一个的第一个值，就进行合并，右边界取第一个和第二个右边界的大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Explanation: Since intervals [<span class="number">1</span>,<span class="number">3</span>] and [<span class="number">2</span>,<span class="number">6</span>] overlaps, merge them into [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] x, <span class="keyword">int</span>[] y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x[<span class="number">0</span>], y[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;intervals.length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        tmp[<span class="number">0</span>] = intervals[start][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur_end = intervals[start][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;intervals.length-<span class="number">1</span> &amp;&amp; cur_end&gt;=intervals[start+<span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            cur_end = Math.max(cur_end, intervals[start+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        tmp[<span class="number">1</span>] = cur_end;</span><br><span class="line">        list.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/301/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/301/" class="post-title-link" itemprop="url">将keras的h5文件转为tensorflow的pb文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-21 13:30:11" itemprop="dateCreated datePublished" datetime="2019-08-21T13:30:11+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/301/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/301/" data-xid="/posts/301/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/301/" class="post-meta-item leancloud_visitors" data-flag-title="将keras的h5文件转为tensorflow的pb文件" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><span>背景</span></h2><p>目前keras框架使用简单，很容易上手，深得广大算法工程师的喜爱，但是当部署到客户端时，可能会出现各种各样的bug，甚至不支持使用keras，本文来解决的是将keras的h5模型转换为客户端常用的tensorflow的pb模型并使用tensorflow加载pb模型。</p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/9/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-17 21:01:20" itemprop="dateCreated datePublished" datetime="2019-08-17T21:01:20+08:00">2019-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/9/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/9/" data-xid="/posts/9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/9/" class="post-meta-item leancloud_visitors" data-flag-title="排序算法" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="各种排序算法复杂度分析"><a href="#各种排序算法复杂度分析" class="headerlink" title="各种排序算法复杂度分析"></a><span>各种排序算法复杂度分析</span></h2><ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
</ul>
<p><img data-src="/images/sort/analysis.png"></p>
<p>在写排序算法之前，先把每种排序算法都用到的数组元素交换的代码写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-selection-sort"><a href="#选择排序-selection-sort" class="headerlink" title="选择排序 (selection sort)"></a><span>选择排序 (selection sort)</span></h2><ul>
<li>选择出数组中的最小元素，将它与数组的第一个元素进行交换；</li>
<li>从剩下的元素中选择出最小的元素，将它与数组的第二个元素进行交换；</li>
<li>直到将整个数组排序。</li>
</ul>
<p><img data-src="/images/sort/selection_sort.gif"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">        <span class="comment">// 寻找 [i, n) 区间里的最小值的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex]&gt;arr[j])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：最稳定的算法之一；时间复杂度为$O(n^2)$；数据规模越小越好；不占用额外空间。</p>
<h2 id="插入排序-insert-sort"><a href="#插入排序-insert-sort" class="headerlink" title="插入排序 (insert sort)"></a><span>插入排序 (insert sort)</span></h2><ul>
<li>从左到右，每次将当前元素插入到左侧已经排好序的数组当中，使插入后左部分数组依然有序；</li>
<li>第 j 个元素不断与左侧元素进行比较，arr[j] &lt; arr[j-1] 就交换两个元素的位置，并j=j-1。</li>
</ul>
<p><img data-src="/images/sort/insert_sort.gif"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j =i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; arr[j]&lt;arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">            j = j-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的代码每次都要交换位置，会浪费时间，优化代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j =i;</span><br><span class="line">    <span class="keyword">int</span> e = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; e&lt;arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">        arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        j = j-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：插入排序通常采用in-place排序（即只需要用O(1)的额外空间的排序），所以在排序过程中，需要不断把元素进行后移，为新的元素插入提供空间。</p>
<h2 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序 (bubble sort)"></a><span>冒泡排序 (bubble sort)</span></h2><ul>
<li>将当前元素与后面的元素逐个比较，若a[j] &gt; a[j+1]，就进行交换，每轮排序后最大值会排到后面去；</li>
<li>当执行一轮循环后，没有发生交换，则表示数组已经有序。</li>
</ul>
<p><img data-src="/images/sort/bubble_sort.gif"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> swap_flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;  <span class="comment">// 因为i后面已经有序了，而且是最大的，所以不需要进行比较了	</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">                swap_flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!swap_flag)  <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序-shell-sort"><a href="#希尔排序-shell-sort" class="headerlink" title="希尔排序 (shell sort)"></a><span>希尔排序 (shell sort)</span></h2><ul>
<li>希尔排序会优先比较距离较远的元素。又叫<strong>缩小增量排序</strong>。</li>
<li>希尔排序把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；</li>
<li>随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</li>
</ul>
<p><img data-src="/images/sort/shell_sort.gif"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i = i + gap)&#123;</span><br><span class="line">            <span class="keyword">int</span> j =i;</span><br><span class="line">            <span class="keyword">int</span> e = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; e&lt;arr[j-gap]) &#123;</span><br><span class="line">                arr[j] = arr[j-gap];</span><br><span class="line">                j = j-gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序-merge-sort"><a href="#归并排序-merge-sort" class="headerlink" title="归并排序 (merge sort)"></a><span>归并排序 (merge sort)</span></h2><ul>
<li>归并排序采用了分治的思想，将大数组化为一个个的小数组去处理，然后再归并到一起。</li>
</ul>
<p><img data-src="/images/sort/merge_sort.gif"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)		</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(arr, left, mid);</span><br><span class="line">    merge_sort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);  <span class="comment">// left到mid是左数组， mid+1到right是右数组，将两个数组合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：merge是被递归调用的，所以不能在这里新建res_arr用来保存结果，只能改变arr的值</span></span><br><span class="line">    <span class="comment">// 要不然结果保存不下来，每次递归就不见了！！</span></span><br><span class="line">    <span class="keyword">int</span>[] res_arr = arr.clone();   <span class="comment">// 我们要改变arr数组，所以要备份一份用来比较</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;mid) &#123;   	  <span class="comment">// 代表左侧的数组已经排序完成，把右侧剩下的直接赋值给arr就好</span></span><br><span class="line">            arr[i] = res_arr[r];</span><br><span class="line">            r += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&gt;right) &#123;  <span class="comment">// 表示右侧的数组已经排序完成，把左侧剩下的直接赋值给arr就好</span></span><br><span class="line">            arr[i] = res_arr[l];</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res_arr[l]&lt;res_arr[r]) &#123;   <span class="comment">// 左侧的值小，要左侧</span></span><br><span class="line">            arr[i] = res_arr[l];</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">// 右侧的值小，要右侧</span></span><br><span class="line">            arr[i] = res_arr[r];</span><br><span class="line">            r += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">0</span>, <span class="number">32</span>&#125;;</span><br><span class="line">    merge_sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序-quick-sort"><a href="#快速排序-quick-sort" class="headerlink" title="快速排序 (quick sort)"></a><span>快速排序 (quick sort)</span></h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一趟快速排序的算法是：</span><br><span class="line"><span class="number">1.</span> 设置两个变量i，j，排序开始的时候：i=<span class="number">0</span>, j=N<span class="number">-1</span>；</span><br><span class="line"><span class="number">2.</span> 以第一个数组元素作为关键元素，赋值给<span class="type">key</span>，即<span class="type">key</span> = arr[<span class="number">0</span>]；</span><br><span class="line"><span class="number">3.</span> 从 j 开始向前搜索，即由后向前开始搜索(j--)，找到第一个小于<span class="type">key</span>的值arr[j], 将arr[j]和<span class="type">key</span>的值进行交换；</span><br><span class="line"><span class="number">4.</span> 从 i 开始向后搜索，即由前向后开始搜索(i++)，找到第一个大于<span class="type">key</span>的值arr[i], 将arr[i]和<span class="type">key</span>的值进行交换；</span><br><span class="line"><span class="number">5.</span> 重复<span class="number">3</span>，<span class="number">4</span>步，直到 i=j。</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/sort/quick_sort.gif" alt="快速排序"></p>
<p><strong>每进行一趟快速排序，都会有一个元素处于最终的位置，它左侧的元素都比他小，它右侧的元素都比他大</strong>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= key &amp;&amp; left &lt; right)</span><br><span class="line">            right -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt;= key &amp;&amp; left &lt; right)</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            arr[right] = arr[left];  </span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> positon = partition(arr, left, right);</span><br><span class="line">    quick_sort(arr, left, positon-<span class="number">1</span>);</span><br><span class="line">    quick_sort(arr, positon+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">0</span>, <span class="number">32</span>&#125;;</span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分按照原始定义要按照下面这种写法，但是因为每次都要交换，所以改成了上面这种。因为一开始key的值已经保存了，所以不需要每次都交换。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[right] &gt;= key &amp;&amp; left &lt; right)</span><br><span class="line">      	right -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">-       arr[left] = arr[right];</span><br><span class="line">+       swap(arr, left, right);</span><br><span class="line">    <span class="keyword">while</span> (arr[left] &lt;= key &amp;&amp; left &lt; right)</span><br><span class="line">      	left += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">-      	arr[right] = arr[left];  </span><br><span class="line">+       swap(arr, left, right);</span><br><span class="line">&#125;</span><br><span class="line">- arr[left] = key;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序-heap-sort"><a href="#堆排序-heap-sort" class="headerlink" title="堆排序 (heap sort)"></a><span>堆排序 (heap sort)</span></h2><h3 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h3><ul>
<li>大顶堆的某个节点的值总是大于等于子节点的值。</li>
<li>堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易存储在数组中。</li>
<li>**位置k的节点的父节点的位置为$k/2$，而它的两个子节点的位置分别为$2k$和$2k+1$**，这里不使用数组索引为0的位置，是为了更清晰地描述节点的位置关系。</li>
<li>用count记录当前堆中元素个数</li>
</ul>
<h3 id="堆的基本操作："><a href="#堆的基本操作：" class="headerlink" title="堆的基本操作："></a>堆的基本操作：</h3><ul>
<li><p>在大顶堆中，当一个节点的值比父节点的值要大，那么就需要交换这两个节点。交换后还可能比它新的父节点大，因此就要不断地进行比较和交换操作。把这种操作成为**上浮(ShiftUp)**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; data[k] &gt; data[k/<span class="number">2</span>]) &#123;</span><br><span class="line">        swap(data, k, k/<span class="number">2</span>);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类似的，当一个节点比子节点小，那么就需要不断地向下进行比较和交换操作，这种操作叫做**下沉(ShiftDown)**。一个节点如果有两个子节点，那么应该与两个子节点中最大的那个节点进行交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> count, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k &lt;= count) &#123;  <span class="comment">// 当前节点有左孩子 </span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> &lt;= count &amp;&amp; data[j] &lt; data[j+<span class="number">1</span>])</span><br><span class="line">           j += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//data[j] 表示左右孩子中的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(data[k] &gt; = data[j])</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        swap(data, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入元素：将新元素放入数组尾部，然后执行上浮，到合适的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> count, <span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个这样写是不对的，因为直接用了数组，到时候可以用list动态增加数组长度</span></span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    data[count] = item;</span><br><span class="line">    shiftUp(data, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除最大元素：从大顶堆中取出堆顶元素，然后将最后一个元素移到堆顶位置，再下沉到合适的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extractMax</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item = data[<span class="number">1</span>];   <span class="comment">// 因为数组0位置没有存储元素</span></span><br><span class="line">    swap(data, <span class="number">1</span>, count);</span><br><span class="line">    shiftDown(data, <span class="number">1</span>);</span><br><span class="line">    count -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h3><ul>
<li><p>由于大顶堆很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆数组中的最后一个元素交换位置，并且不删除它，就可以得到一个递增序列。（其实也可以构造小顶堆，和上面的方法差不多）。堆排序是原地排序，不需要额外空间。</p>
</li>
<li><p>把MaxHeap当作一个类，上面都是他的内部函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = arr.length;</span><br><span class="line">      MaxHeap&lt;Integer[]&gt; maxHeap = <span class="keyword">new</span> MaxHeap();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++) &#123;</span><br><span class="line">         maxHeap.insert(arr, count, i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">         arr[i] = maxHeap.extractMax(arr, count);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="计数排序-counting-sort"><a href="#计数排序-counting-sort" class="headerlink" title="计数排序 (counting sort)"></a><span>计数排序 (counting sort)</span></h2><ul>
<li><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</p>
</li>
<li><p>算法描述：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
</li>
</ul>
<p><img data-src="/images/sort/count_sort.gif"></p>
<h2 id="桶排序-bucket-sort"><a href="#桶排序-bucket-sort" class="headerlink" title="桶排序 (bucket sort)"></a><span>桶排序 (bucket sort)</span></h2><h2 id="基数排序-radix-sort"><a href="#基数排序-radix-sort" class="headerlink" title="基数排序 (radix sort)"></a><span>基数排序 (radix sort)</span></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><span>注释</span></h2><p>文中图片来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.dlzhang.com/posts/300/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="二次元/coser/手办宅/程序媛">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醉里挑灯赏猫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/300/" class="post-title-link" itemprop="url">准确率，精确率，召回率和AUC曲线，PR曲线</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发布：</span>

      <time title="创建时间：2019-08-17 14:11:16" itemprop="dateCreated datePublished" datetime="2019-08-17T14:11:16+08:00">2019-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类：</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/overview/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">评论：</span>
  
    <a title="waline" href="/posts/300/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/posts/300/" data-xid="/posts/300/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/posts/300/" class="post-meta-item leancloud_visitors" data-flag-title="准确率，精确率，召回率和AUC曲线，PR曲线" title="阅读">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们都知道机器学习要建模，但是对于模型性能的好坏（即模型的泛化能力），我们并不知道是怎样的，很可能这个模型就是一个差的模型，泛化能力弱，对测试集不能很好的预测或分类。那么如何知道这个模型是好是坏呢？我们必须有个评判的标准。<strong>为了了解模型的泛化能力，我们需要用某个指标来衡量，这就是性能度量的意义。</strong>有了一个指标，我们就可以对比不同模型了，从而知道哪个模型相对好，那个模型相对差，并通过这个指标来进一步调参逐步优化我们的模型。</p>
          <!--noindex-->
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alyssa</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://blog-waline-five.vercel.app/","placeholder":"Just go go","dark":"auto","avatar":"wavatar","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredMeta":["nick","mail"],"copyright":true,"login":"","avatarCDN":"https://sdn.geekzu.org/avatar/","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq"],"locale":{"placeholder":"在这里分享你的观点与想法～ 昵称、邮箱必填，邮件通知回复。","admin":"博主","nick":"昵称*","mail":"邮箱*","link":"网址（http://）"},"el":"#waline-comments","libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","path":"/page/2/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  if(CONFIG.waline.qiniuDomain && CONFIG.waline.qiniuTokenUrl){
    CONFIG.waline.uploadImage = qiniuUploadImage;
  }
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>





</body>
</html>
